#+TITLE: Making of: Line drawing on a grid
#+DATE: <2017-05-15>

#+begin_export html
<style>
iframe:not(.frameless) { 
    border-radius: 5px; 
    border: 1px solid hsl(0,10%,80%); 
    padding: 10px 23px; 
    box-shadow: inset 0 0 5px rgba(0,0,0,0.2); 
    background-color: hsl(60,10%,95%); 
}
iframe.frameless {
    border: none;
}
button {
    margin-right: 1em;
}
</style>
#+end_export

People have asked me how I write my interactive tutorials. I can point at the final result but the final result doesn't show the /process/. On this page I'll recreate the first half of my [[http://www.redblobgames.com/grids/line-drawing.html][line drawing tutorial]]:

#+begin_export html
<!-- 750 == 600 / 0.8 -->
<iframe id="iframe" src="/grids/line-drawing.html#interpolation" width="750" height="300"  style="transform:scale(0.8);transform-origin:left top"/>
#+end_export

It's a medium sized project for me, with multiple diagrams, multiple layers in each diagram, draggable handles, and scrubbable numbers. I'll include pointers to the code in each step.

* Web page
:PROPERTIES:
:CUSTOM_ID: web-page
:END:

I usually start with a basic web page template that includes scripts, footers, etc.

#+begin_export html
<iframe src="1/" width="600" height="200"/>
#+end_export

#+include: "1/index.html" src html

I'll omit the header and footer from the rest of the examples.

** TODO Tense

Do I want present tense or future tense? Imperative or declarative? Go through the text and make sure it's all consistent

** TODO Links to code

Link to the github folders

* Diagram
:PROPERTIES:
:CUSTOM_ID: diagram
:END:

Sometimes I'll add a diagram first and then add some text; other times I'll start with the text and then figure out the diagrams. For this page I'll start with a diagram.

The tutorial is about drawing lines on a square grid, so I need to draw a grid and also draw lines. However, that's not where I start. As much as possible, I want to get /something/ working as soon as possible, so I'll start with a blank diagram and an empty javascript file:

#+begin_export html
<iframe src="2-blank/" width="600" height="250"/>
#+end_export

#+include: "2-blank/index.html" src html

I attach an ~id=~ to an html element so that I can get to it from Javascript, using ~document.getElementById~. Sometimes I'll attach it to the ~<svg>~ and sometimes to a ~<div>~ outside the svg.

I'll draw a grid with Javascript, using the [[https://d3js.org/][d3.js library]]:

#+begin_export html
<iframe src="2-grid/" width="600" height="250"/>
#+end_export

#+include: "2-grid/line-drawing.js" src js :lines "4-"

There's some tweaking on grid sizes. I could parameterize it and calculate it properly but often times I will hard-code it when I'm just starting out, and only calculate it if I need to. Here my svg is 550px wide and I picked squares that are 22px, so 25 of them fit across. Vertically I can fit 10 squares in 220px so I changed the svg height from 200 to 220 to fit.

Those of you who know SVG might choose to use =viewBox= or =transform= to change the coordinate system to place points at the center of each grid square instead of at the top left, and also to scale things so that each grid square is 1 unit across instead of =scale= pixels. I did this in the original article but I didn't for this tutorial.

The next thing I need is the code to calculate the points on the line, and code to draw those points.

#+begin_export html
<iframe src="2-line/" width="600" height="250"/>
#+end_export

#+include: "2-line/line-drawing.js" src js :lines "18-"

Hooray, it works!

This is just the beginning. It's a working implementation of the algorithm and a working diagram. But it's not /interactive/.

* Interaction
:PROPERTIES:
:CUSTOM_ID: interaction
:END:

What I most often do for interaction is let the reader change the inputs to the algorithm. For line drawing, the inputs are the two endpoints, =A= and =B= in the code.

#+begin_export html
<iframe src="3-draggable/" width="600" height="250"/>
#+end_export

#+include: "3-draggable/line-drawing.js" src js :lines "31-"

Great! It's pretty easy with [[https://github.com/d3/d3-drag][d3-drag]]. To help the reader know which elements are interactive, I set the CSS =cursor:move= over the draggable circles. 

This code lets me update =A= and =B= but it doesn't recalculate the line. To be able to update the line, I need to move the drawing code into a function that I can call again, and I also need to reuse the =<rect>= elements I've previously created. It's useful to use the [[https://github.com/d3/d3-selection][d3-selection]] pattern here; it will let me reuse, create, or remove elements as my data changes. To use it, I need a container for the =<rect>= elements; I put it in a variable ~gPoints~. I also need to separate the logic for the /algorithm/ (function ~pointsOnLine~) from the logic for /drawing/ (function ~redraw~).

#+begin_export html
<iframe src="3-redraw/" width="600" height="250"/>
#+end_export

#+include: "3-redraw/line-drawing.js" src js :lines "18-"

Great! Now I have an interactive diagram. But this isn't an /explanation/.

* Steps
:PROPERTIES:
:CUSTOM_ID: steps
:END:

To explain how an algorithm works, I sometimes break it down into the steps of the execution and sometimes into the steps of the code. For a tutorial like [[http://www.redblobgames.com/pathfinding/a-star/introduction.html][my introduction to A*]], I showed the execution. For line drawing, I listed the steps in the code:

- Linear interpolation (lerp)
  - of numbers
  - of points
- Number of steps in the line
  - diagonal distance
- Rounding
  - of numbers
  - of points

Since I'm going to have multiple diagrams, it'll be useful to encapsulate all those global variables and functions into a diagram object.

#+begin_export html
<iframe src="4/" width="600" height="250"/>
#+end_export

#+include: "4/line-drawing.js" src js :lines "21-"

A pattern is starting to form, but I haven't made use of it yet. There's a =<g>= for each visual layer:

- the grid
- the line
- the draggable handles

Each of these layers has some code to draw it and sometimes some code to update it. As I add more layers to the diagram I'll do something better with the draw and update code.

* Linear interpolation of numbers
:PROPERTIES:
:CUSTOM_ID: lerp-numbers
:END:

In this section I don't actually have a diagram, but I do have some interaction, so I'm going to use a diagram object anyway without an svg. I want to drag a number left and right to change it, and see how it affects some calculations. Take a look at Bret Victor's [[http://worrydream.com/Tangle/][Tangle library]] for inspiration. You might want to use his library directly. For this page I used [[https://github.com/d3/d3-drag][d3-drag]] instead.

How did I want this to work?

- I want to be able to “scrub” (drag) a number left/right.
- I want to choose the formatting (e.g. =1.00= vs =1.0= vs =1=).
- I want to be able to run the update function when the number changes.

There are other things that you may want for scrubbable numbers but these are all I needed for this tutorial. I decided that within a named ~<div>~ section I'd find all the ~<span data-name="XYZ">~ and turn them into scrubable numbers stored in field XYZ. I ended up only having two names, =t= and =N=, but I didn't realize this until later.

#+begin_export html
<iframe src="5/" width="600" height="150"/>
#+end_export

Scrubbable numbers are cool but a little bit tricky. I used d3-drag to tell me how far left/right the mouse was dragged. Then I scaled the relative mouse position from -100 pixels to +100 pixels to the desired low–high range, using a linear scaling (see =positionToValue=):

#+include: "5/line-drawing.js" src js :lines "21-"

When the number is dragged, I updated the display of the number, and I also called the diagram's =update= function to update any other aspect of the diagram. I also set the CSS to =cursor:col-resize= so that the reader can see it's interactive.

* Linear interpolation of points
:PROPERTIES:
:CUSTOM_ID: lerp-points
:END:

Using linear interpolation of numbers, I wanted to display the linear interpolation of points. I wanted a diagram that lets you modify 0 ≤ t ≤ 1, and shows the resulting point.
Until now I had the final algorithm written in =pointsOnLine=. To split up the diagrams I also need to split the line drawing algorithm into separate steps.

#+include: "6/line-drawing.js" src js :lines "8-16"

#+begin_export html
<iframe src="6/" width="600" height="300"/>
#+end_export

I'm starting to organize things in terms of layers:

#+include: "6/line-drawing.js" src js :lines "38-65"

Note that this diagram does /not/ show the line drawn on a grid. That's another reason I want to use diagram layers for this page.

* Layers
:PROPERTIES:
:CUSTOM_ID: layers
:END:

There are now two diagrams on the page. Both display the grid. The first diagram displays the grid line. The second diagram shows a non-grid line and also the interpolated point. There will be more diagrams soon. When I'm writing a tutorial that requires multiple diagrams, each with different features, I like to divide the diagrams into /layers/, and then stack them on top of each other. There are four layers in the previous diagram: /grid/, /track/, /interpolation point/, and /drag handle/:

#+begin_export html
<iframe class="frameless" src="7/" width="600" height="300"/>
#+end_export

Each layer will be created by a method that adds a =<g>= for a layer, and also adds its /update/ function to the diagram object. Here's the code for managing the update functions:

#+include: "7/line-drawing.js" src js :lines "19-35"

I no longer need to put the =<g>= elements into fields in the diagram object (e.g. =gGrid=, =gHandles=, etc.); they can remain local variables in the =add= functions. Look at =addTrack()= now:

#+include: "7/line-drawing.js" src js :lines "51-66"

I can now assemble a diagram by calling the =addXYZ()= functions:

#+include: "7/line-drawing.js" src js :lines "140-"

I /don't/ have a generic layer system that I use across my tutorials. I make one specific for each tutorial that needs it. Each tutorial's needs have been different. The one here is only 8 lines of code; it's not worth writing a separate library for that.

* Number of steps in the line
:PROPERTIES:
:CUSTOM_ID: number-of-steps
:END:

The third diagram has yet a different visualization layer, but it will be easier to implement now that I have layers. Until now I had the line drawing algorithm choose N. I need to separate that out too.

#+include: "8/line-drawing.js" src js :lines "17-26"

#+begin_export html
<iframe src="8/" width="600" height="350"/>
#+end_export

The drawing code turns out to be very similar to the previous case so I made it read either /t/ or /N/:

#+include: "8/line-drawing.js" src js :lines "76-97"

I also had to extend my scrubbable number implementation. Previously, I wanted floating point values but here I want it to round to an integer. I decided the easiest way to do this was to =parseFloat= the formatted output; that way it'd work no matter how many digits I'm rounding to. See the =formatter= in =makeScrubbableNumber()=.

I also added another layer for labels:

#+include: "8/line-drawing.js" src js :lines "98-119"

The labels are overlapping the drag handles. This and a lot of other things I'll fix later.

* Rounding
:PROPERTIES:
:CUSTOM_ID: rounding
:END:

We already know how to round numbers to the nearest integer. To snap points to the grid we can round both the =x= and =y= values.

#+include: "9/line-drawing.js" src js :lines "25-28"

I drew this on another layer.

#+begin_export html
<iframe src="9/" width="600" height="300"/>
#+end_export

I also want to tell people when they've reached the optimal N, which is max(Δx,Δy).

This diagram has all the essential components but it could look nicer.

* Finishing touches
:PROPERTIES:
:CUSTOM_ID: extras
:END:

Although I have the essentials working, I usually spend a lot of time after that making the diagrams both look good and feel good.

- The code I originally wrote fails when the line distance is zero, e.g. when the start and end points are the same. I added a special case in =interpolationPoints= for ~N == 0~.
- You can drag the markers outside the grid; I restricted that movement.
- It's often better to specify the styles in CSS so that you can override them for a specific diagram.
- It's usually better to use HSL colors than RGB colors; they're much easier to work with. My rule of thumb is to start with medium colors =hsl(h,50%,50%)= for any 0 ≤ h < 360, and then tweak saturation and lightness.

- [ ] The grid looks better when the borders /aren't/ drawn; to make that work I need to shrink the boxes by one pixel so that there's a gap between them.
- [ ] {Track} wider, translucent to see grid underneath
- [ ] The drag handles would look nice when they fit into the "track", but we want the mouse-sensitive hit area to continue to be large. Smaller handles also don't interfere with labels and the squares that show the drawn line.
- [ ] Once the track is wider we can place smaller interpolation points into it, with border
- [ ] If I make the rounded point squares translucent you can see the track underneath, with border too
- [ ] Mouse pointer
- [ ] Scrubbable number hit size, consistent size
- [ ] Drop shadows

#+begin_export html
<iframe src="10/" width="600" height="300"/>
#+end_export


* Putting it all together
:PROPERTIES:
:CUSTOM_ID: final
:END:

{diagram}

#+begin_export html
<script src="https://d3js.org/d3.v4.min.js"/>
<script src="making-of.js"/>
#+end_export

#+begin_footer
Created May 2017
with [[http://orgmode.org/][Emacs Org-mode]], from [[file:index.org][index.org]]. Diagram use [[https://d3.org/][d3.js v4]]. All the HTML, CSS, and Javascript on the page is available [[https://github.com/redblobgames/making-of-line-drawing][on github/redblobgames]].
Page last modified {{{modification-time(%F)}}}.
#+end_footer
